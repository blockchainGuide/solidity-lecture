## 概念

erc1155是一个新型的代币标准，结合ERC20，ERC721，ERC777中的一些功能，所形成的高效的代币合约标准。

## 多代币标准
ERC1155 的显着特点是它使用单个智能合约同时代表多个代币。这就是为什么他的balanceof 不同于ERC20 和ERC777，它有一个额外的id参数，用于表示要查询其余额的代币标识符。

这类似于 ERC721 的工作方式，但在该标准中，token ID 没有balance的概念：每个token 都是不可替代的，存在或不存在. ERC721 balanceOf 函数指的是一个账户拥有多少种不同的代币，而不是每种代币的数量。
在 ERC1155 中，每个 token ID 的账户都有不同的余额，而 NFT 是通过 mint 其中一个来实现的.
这种方法可以为需要多个代币的项目节省大量gas.无需为每种代币类型部署新合约，单个 ERC1155 代币合约即可保存整个系统状态，从而降低部署成本和复杂性。

## 批量操作
由于所有状态都保存在单个合约中，因此可以非常高效地在单个交易中对多个代币进行操作。该标准提供了 balanceOfBatch 和 safeBatchTransferFrom 两个函数，它们使查询多个余额和转移多个代币变得更简单，而且gas更少.

## 如何构建ERC1155合约

与 ERC20 不同，ERC1155 缺少小数字段，因为每个tokne都是不同的且无法分割。

ERC1155 合约包括可选的扩展 IERC1155MetadataURI。 这就是 uri 函数的来源(https://docs.openzeppelin.com/contracts/3.x/api/token/erc1155#IERC1155MetadataURI-uri-uint256-)：我们使用它来检索元数据 uri。

```solidity
uri(uint256 id) → string
```
返回token type id 的 URI。
uri 可以包含字符串 {id}，客户端必须将其替换为实际的令牌 ID，十六进制小写（没有 0x 前缀），前导零填充为 64 个十六进制字符。
对于令牌ID 2和URI的https：//game.example/api/item/(id.json 客户端将取代（id）与0000000000000000000000000000000000000000000000000000000000000002在HTTPS检索JSON：//game.example/api/item/0000000000000000000000000000000000000000000000000000000000000002.json .
比如token id 为2 的json文档如下：
```json
{
    "name": "Thor's hammer",
    "description": "Mjölnir, the legendary hammer of the Norse god of thunder.",
    "image": "https://game.example/item-id-8u5h2m.png",
    "strength": 20
}
```

> note
> 你会注意到项目的信息包含在元数据中，但该信息不在链上！ 所以游戏开发者可以改变底层元数据，改变游戏规则！

## 向合约发送代币
使用 safeTransferFrom 时的一个主要区别是，代币转移到其他合约可能会返回以下消息：
```
ERC1155: transfer to non ERC1155Receiver implementer
```
这表示接收方合约尚未将自己注册为ERC1155 协议， 因此禁止向其转移以防止令牌永远被锁定。
为了让我们的合约接收 ERC1155 代币，我们可以继承 便利合约 ERC1155Holder，它为我们处理注册。虽然我们需要记住实现允许从我们的合约中转移代币的功能：
```solidity
// contracts/MyContract.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol";

contract MyContract is ERC1155Holder {
}
```
我们还可以使用 onERC1155Received 和 onERC1155BatchReceived 函数实现更复杂的场景。


## 预设ERC1155合约



## API 详解
ERC1155 由三个主要接口组成，IERC1155， IERC1155MetadataURI 和 IERC1155Receiver。
要实现ERC1155合约，必须强制实现IERC1155合约，IERC1155MetadataURI 是可选的接口，通过依赖替换机制对所有令牌类型使用相同的 URI，大大降低了 gas 成本。
此外，还有多个自定义扩展，包括：
- 指定可以为所有用户暂停代币传输的地址 (ERC1155Pausable)。
- 销毁自己的代币（ERC 1155 Burnable）

这组核心合约被设计为无主见，允许开发人员访问 ERC1155 中的内部函数（例如 _mint），并以他们喜欢的方式将它们公开为外部函数。 另一方面，ERC1155 Presets（例如 ERC1155PresetMinterPauser）是使用自以为是的模式设计的，为开发人员提供即用型、可部署的合约.

### core
#### IERC1155
```solidity
// 根据地址指定的tokenID 获取amount， 地址不能为0地址
balanceOf(address account, uint256 id) → uint256
```

```solidity
// accounts 一一对应ids,   即长度必须一致。
balanceOfBatch(address[] accounts, uint256[] ids) → uint256[]
```
```solidity
// operator 不能是 caller , caller 可以选择
setApprovalForAll(address operator, bool approved)
```

```solidity
// 返回operator是否被允许去转让account的tokens
isApprovedForAll(address account, address operator) → bool
```

```solidity
// 转让指定token类型的指定数量给to地址
safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data)

```
- to不能是零地址
- 如果调用者不是caller，它必须已经通过setApprovalForAll来被允许传输。
- from必须有余额
- 如果to是一个智能合约的地址的话，必须实现IERC1155Receiver.onERC1155Received， 并且返回接收者的magic value（？？？） ，这里opzepplin提供现成的实现，只需要继承即可。ERC1155holder。

```solidity
safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)
```
- ids和amounts必须拥有相同的数量
- 如果to是一个智能合约的地址的话，必须实现IERC1155Receiver.onERC1155Received， 并且返回接收者的magic value（？？？） ，这里opzepplin提供现成的实现，只需要继承即可。ERC1155holder。

```solidity
URI(string value, uint256 id)
```





## 参考
> https://docs.openzeppelin.com/contracts/3.x/erc1155


